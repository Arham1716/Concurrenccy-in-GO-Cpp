# Concurrent Programming Solutions in C++ and Go

This project provides a web-based platform to visualize the performance characteristics of classic concurrent programming problems implemented in C++ and Go. While the core concurrent solutions are handled by separate backend processes, this repository focuses on the frontend application responsible for displaying the collected performance data, including execution times, CPU/resource usage, and memory consumption, through intuitive graphs.

## Features

-   **Web-based Visualization:** An interactive frontend application built to display performance graphs.
-   **Comparative Analysis:** View and compare performance metrics for C++ and Go implementations side-by-side.
-   **Problem-Specific Views:** Navigate through different concurrent problems to see their respective performance data.
---

## Problems Visualized

This application is designed to display performance data for concurrent solutions to the following classic problems:

-   **Reader-Writer Problem:** Safe access to shared data.
-   **Producer-Consumer Problem:** Synchronization between data generators and consumers.
-   **Dining Philosophers Problem:** Resource allocation and deadlock avoidance.
-   **Dining Savages Problem:** A variation on producer-consumer with unique synchronization.
-   other problems include santa clause, river crossing, FIFO Barbershop etc.

---

## Performance Metrics Displayed

The frontend visualizes the following key performance metrics, which are generated by the backend processes running the C++ and Go executables:

-   **Execution Time:** The total time taken for each concurrent solution to complete.
-   **CPU/Resource Usage:** Graphs showing CPU utilization and overall system resource consumption.
-   **Memory Usage:** Charts illustrating the memory footprint of the running programs.

These visualizations help in understanding the performance trade-offs and efficiencies of C++ versus Go for common concurrent programming challenges.


## Setup and Running

To set up and run this project, follow these steps:

1.  **Clone the repository:**
    ```bash
    git clone [https://github.com/your-username/your-repo-name.git](https://github.com/your-username/your-repo-name.git)
    cd your-repo-name
    ```

2.  **Build C++ Executables:**
    Use the problems given and build the executables. You will need a C++ compiler (e.g., g++).
    ```bash
    # Example for one solution
    g++ -pthread -o reader_writer reader_writer.cpp
    ```
    Ensure the compiled `.exe` files are accessible by the Flask application (or placed in a designated `backend/cpp` directory).

3.  **Build Go Executables:**
    Navigate to each Go solution directory (`backend/go`) and build the executables. You will need the Go toolchain.
    ```bash
    # Example for one solution
     go build -o my_program.exe my_program.go
    ```
    Ensure the compiled executables are accessible by the Flask application.

4.  **Install Python Dependencies:**
    ```bash
    pip install -r requirements.txt
    ```

5.  **Run the Flask Application:**
    ```bash
    cd flask_app
    python app.py     #For c++
    python goApp.py   #For Go
    ```
    The Flask application will typically run on `http://127.0.0.1:5000`. Access this URL in your web browser to interact with the application and trigger the execution of the concurrent solutions.

6.  **Run Analysis Scripts:**
    After collecting data through the Flask application, navigate to the `src/assets` directory for graphs.
    # The graphs are created by separated tools and they cannot be created at runtime so we added the graphs for display.

## Results and Analysis

The `src/assets` directory will contain the raw performance data collected from difference performance tools. The `src/assets` will show various graphs (for execution time, line graphs for CPU/memory usage over time) illustrating the performance characteristics of C++ and Go solutions for each problem.

## Technologies Used

-   **C++:** For high-performance concurrent implementations, thanks to it's thread support.
-   **Go:** For efficient and idiomatic concurrent implementations, through Go-routines.
-   **Python:**
    -   **Flask:** Web framework for running and managing executables.

## Contributing

Contributions to this project are welcome! If you have suggestions for improvements, new concurrent problems to implement, or better analysis techniques, feel free to open an issue or submit a pull request.

## License

This project is licensed under the [MIT License](LICENSE)       
